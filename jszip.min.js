/*!
 * JSZip - A JavaScript class for generating and reading zip files
 * Minimal self-contained implementation compatible with the ChibiTheme Studio usage.
 * Supports: new JSZip(), .folder(), .file(), .generateAsync({type:'blob'})
 * Based on the public JSZip API (https://stuk.github.io/jszip/)
 */
(function(global){
"use strict";

// --- CRC32 Table ---
var crcTable = (function(){
  var c, table = [];
  for(var n=0; n<256; n++){
    c = n;
    for(var k=0; k<8; k++) c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
    table[n] = c;
  }
  return table;
})();

function crc32(crc, buf){
  crc = crc ^ (-1);
  for(var i=0; i<buf.length; i++) crc = (crc >>> 8) ^ crcTable[(crc ^ buf[i]) & 0xFF];
  return (crc ^ (-1)) >>> 0;
}

function dosDate(d){
  return ((d.getFullYear()-1980) << 25) | ((d.getMonth()+1) << 21) | (d.getDate() << 16) |
         (d.getHours() << 11) | (d.getMinutes() << 5) | (d.getSeconds() >> 1);
}

function uint16(v){ return [v & 0xFF, (v >> 8) & 0xFF]; }
function uint32(v){ return [v & 0xFF, (v >> 8) & 0xFF, (v >> 16) & 0xFF, (v >> 24) & 0xFF]; }

function concat(arrays){
  var total = arrays.reduce((s,a)=>s+a.length,0);
  var out = new Uint8Array(total), offset = 0;
  for(var a of arrays){ out.set(a, offset); offset += a.length; }
  return out;
}

function strToBytes(str){
  return new TextEncoder().encode(str);
}

function blobToUint8Array(blob){
  return new Promise(function(resolve){
    var reader = new FileReader();
    reader.onload = function(e){ resolve(new Uint8Array(e.target.result)); };
    reader.readAsArrayBuffer(blob);
  });
}

function arrayBufferToUint8Array(ab){
  return new Uint8Array(ab);
}

// --- JSZip core ---
function JSZip(){ this._files = []; }

JSZip.prototype.folder = function(name){
  // Return a proxy that prefixes all .file() calls
  var parent = this;
  var prefix = name.replace(/\/?$/,'/');
  return {
    file: function(fname, data){ parent.file(prefix+fname, data); return this; },
    folder: function(subname){ return parent.folder(prefix+subname); }
  };
};

JSZip.prototype.file = function(name, data){
  this._files.push({ name: name, data: data, date: new Date() });
  return this;
};

JSZip.prototype.generateAsync = function(options, onUpdate){
  options = options || {};
  var type = options.type || 'blob';
  var files = this._files;
  var total = files.length;

  // We need to convert all blobs/arraybuffers to Uint8Array first
  var promises = files.map(function(f){
    if(f.data instanceof Blob){
      return blobToUint8Array(f.data).then(function(bytes){ return {name:f.name, bytes:bytes, date:f.date}; });
    } else if(f.data instanceof ArrayBuffer){
      return Promise.resolve({ name:f.name, bytes:arrayBufferToUint8Array(f.data), date:f.date });
    } else if(typeof f.data === 'string'){
      return Promise.resolve({ name:f.name, bytes:strToBytes(f.data), date:f.date });
    } else if(f.data instanceof Uint8Array){
      return Promise.resolve({ name:f.name, bytes:f.data, date:f.date });
    } else {
      return Promise.resolve({ name:f.name, bytes:new Uint8Array(0), date:f.date });
    }
  });

  return Promise.all(promises).then(function(entries){
    var localHeaders = [];
    var centralDir = [];
    var offset = 0;

    for(var i=0; i<entries.length; i++){
      var entry = entries[i];
      var namBytes = strToBytes(entry.name);
      var data = entry.data instanceof Blob ? entry._bytes : entry.bytes;
      var crc = crc32(0, data);
      var dd = dosDate(entry.date);

      // Local file header
      var lh = new Uint8Array([
        0x50,0x4B,0x03,0x04,  // signature
        20,0,                  // version needed
        0,0,                   // flags
        0,0,                   // compression (STORE)
        ...uint16(dd & 0xFFFF),// mod time
        ...uint16(dd >> 16),   // mod date
        ...uint32(crc),
        ...uint32(data.length),
        ...uint32(data.length),
        ...uint16(namBytes.length),
        0,0                    // extra field length
      ]);
      var localEntry = concat([lh, namBytes, data]);
      localHeaders.push(localEntry);

      // Central directory entry
      var cd = new Uint8Array([
        0x50,0x4B,0x01,0x02,  // signature
        20,0,                  // version made by
        20,0,                  // version needed
        0,0,                   // flags
        0,0,                   // compression (STORE)
        ...uint16(dd & 0xFFFF),
        ...uint16(dd >> 16),
        ...uint32(crc),
        ...uint32(data.length),
        ...uint32(data.length),
        ...uint16(namBytes.length),
        0,0,                   // extra field length
        0,0,                   // comment length
        0,0,                   // disk number start
        0,0,                   // internal attributes
        0,0,0,0,               // external attributes
        ...uint32(offset)      // relative offset of local header
      ]);
      centralDir.push(concat([cd, namBytes]));
      offset += localEntry.length;

      if(onUpdate) onUpdate({ percent: Math.round((i+1)/entries.length*95) });
    }

    var cdOffset = offset;
    var cdSize = centralDir.reduce((s,a)=>s+a.length,0);
    var eocd = new Uint8Array([
      0x50,0x4B,0x05,0x06,  // signature
      0,0,                   // disk number
      0,0,                   // disk with CD
      ...uint16(entries.length),
      ...uint16(entries.length),
      ...uint32(cdSize),
      ...uint32(cdOffset),
      0,0                    // comment length
    ]);

    var zipBytes = concat([...localHeaders, ...centralDir, eocd]);
    if(onUpdate) onUpdate({ percent: 100 });

    if(type === 'blob'){
      return new Blob([zipBytes], { type: 'application/zip' });
    } else if(type === 'uint8array'){
      return zipBytes;
    } else if(type === 'arraybuffer'){
      return zipBytes.buffer;
    } else {
      return zipBytes;
    }
  });
};

global.JSZip = JSZip;

})(typeof window !== 'undefined' ? window : this);
